# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - - - THE FOLLOWING CODE WAS GENERATED BY SMART GPT 5.1 USING COPILIOT! - - -
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
import sys

# --- Instruction encodings ---
OPCODES = {
    "LOADI": lambda args: [1, int(args[0])],
    "STORE": lambda args: [2, int(args[0])],
    "MOV":   lambda args: [3, int(args[0]), int(args[1])],
    "PUSH2": lambda args: [4],
    "ACC2R1": lambda args: [5],
    "ACC2Q": lambda args: [6],
    "CLRQ": lambda args: [7],
    "SUM": lambda args: [8],
    "MUL": lambda args: [9],
    "RESET": lambda args: [11],
    "DRAW": lambda args: [12, int(args[0]), int(args[1]), int(args[2])],
    "SAVEIP": lambda args: [13],
    "INC3": lambda args: [16],
    "ERROR": lambda args: [17],
    "CLRERR": lambda args: [18],
    "CMP": lambda args: [20],
    "HALT": lambda args: [11],
}

def expand_jump(op, addr):
    # JMP and JZ pseudoâ€‘ops
    if op == "JMP":
        return [1, addr, 3, 1, 2, 14]
    elif op == "JZ":
        return [1, addr, 3, 1, 2, 15]
    else:
        raise ValueError(f"Unknown jump op: {op}")


# ---------------------------------------------------------
# Utility: strip comments and whitespace
# ---------------------------------------------------------
def clean_line(line):
    # Remove comments after ';'
    if ";" in line:
        line = line.split(";", 1)[0]
    return line.rstrip("\n")


# ---------------------------------------------------------
# PASS 0: Parse variables and constants
#   var x = 0        -> allocate RAM, emit init code
#   const WIDTH = 60 -> compile-time constant, no RAM
# ---------------------------------------------------------
def parse_vars_and_consts(lines):
    variables = {}      # name -> RAM address
    consts = {}         # name -> integer value
    initializers = []   # list of init instructions as strings
    ram_ptr = 0

    remaining = []

    for orig in lines:
        line = clean_line(orig).strip()
        if not line:
            continue

        if line.startswith("var "):
            # Format: var name = value
            # Example: var x = 0
            parts = line.split()
            if len(parts) != 4 or parts[2] != "=":
                raise ValueError(f"Invalid var declaration: {line}")
            _, name, _, value_str = parts
            value = int(value_str)

            if name in variables or name in consts:
                raise ValueError(f"Duplicate symbol: {name}")

            addr = ram_ptr
            variables[name] = addr
            ram_ptr += 1

            # Emit initialization code:
            # LOADI value
            # MOV 1 2
            # STORE addr
            initializers.append(f"LOADI {value}")
            initializers.append("MOV 1 2")
            initializers.append(f"STORE {addr}")

        elif line.startswith("const "):
            # Format: const NAME = value
            parts = line.split()
            if len(parts) != 4 or parts[2] != "=":
                raise ValueError(f"Invalid const declaration: {line}")
            _, name, _, value_str = parts
            value = int(value_str)

            if name in variables or name in consts:
                raise ValueError(f"Duplicate symbol: {name}")

            consts[name] = value

        else:
            remaining.append(orig)

    return variables, consts, initializers, remaining


# ---------------------------------------------------------
# PASS 0.5: Parse macros
#   macro NAME arg1 arg2 ...
#       ...
#   end
# ---------------------------------------------------------
def parse_macros(lines):
    macros = {}   # name -> (param_list, body_lines)
    out = []

    i = 0
    while i < len(lines):
        orig = lines[i]
        line = clean_line(orig).strip()
        if not line:
            i += 1
            continue

        parts = line.split()
        if parts[0].lower() == "macro":
            if len(parts) < 2:
                raise ValueError(f"Invalid macro header: {line}")
            name = parts[1]
            params = parts[2:]

            body = []
            i += 1
            while i < len(lines):
                inner_orig = lines[i]
                inner = clean_line(inner_orig).strip()
                if inner.lower() == "end":
                    break
                body.append(inner_orig)
                i += 1
            else:
                raise ValueError(f"Missing 'end' for macro {name}")

            macros[name] = (params, body)
            i += 1  # skip the 'end' line
        else:
            out.append(orig)
            i += 1

    return macros, out


# ---------------------------------------------------------
# Macro expansion
#   Replace macro calls with body, substituting parameters.
# ---------------------------------------------------------
def expand_macros(lines, macros):
    expanded = []

    for orig in lines:
        line = clean_line(orig).strip()
        if not line:
            expanded.append(orig)
            continue

        parts = line.split()
        name = parts[0]

        if name in macros:
            params, body = macros[name]
            args = parts[1:]
            if len(args) != len(params):
                raise ValueError(f"Macro {name} expects {len(params)} args, got {len(args)} in line: {line}")

            # Build substitution map param -> arg
            sub = dict(zip(params, args))

            for body_line in body:
                body_clean = clean_line(body_line)
                body_parts = body_clean.split()
                new_parts = []
                for p in body_parts:
                    if p in sub:
                        new_parts.append(sub[p])
                    else:
                        new_parts.append(p)
                expanded.append(" ".join(new_parts))
        else:
            expanded.append(orig)

    return expanded


# ---------------------------------------------------------
# Substitute variables and constants
#   Variables -> their RAM address
#   Consts    -> their literal value
# ---------------------------------------------------------
def substitute_symbols(lines, variables, consts):
    out = []

    for orig in lines:
        base = clean_line(orig)
        stripped = base.strip()
        if not stripped:
            out.append(orig)
            continue

        # Labels and directives may appear; we only replace tokens that match
        parts = stripped.split()
        new_parts = []
        for p in parts:
            if p in variables:
                new_parts.append(str(variables[p]))
            elif p in consts:
                new_parts.append(str(consts[p]))
            else:
                new_parts.append(p)
        out.append(" ".join(new_parts))

    return out


# ---------------------------------------------------------
# PASS 1: Label collection with .org and .byte
# ---------------------------------------------------------
def first_pass(lines):
    labels = {}
    pc = 0

    for orig in lines:
        line = clean_line(orig).strip()
        if not line:
            continue

        if line.endswith(":"):
            label = line[:-1]
            if label in labels:
                raise ValueError(f"Duplicate label: {label}")
            labels[label] = pc
            continue

        parts = line.split()
        op = parts[0].upper()

        if op == ".ORG":
            if len(parts) != 2:
                raise ValueError(f".org requires one argument: {line}")
            addr = int(parts[1])
            pc = addr

        elif op == ".BYTE":
            if len(parts) < 2:
                raise ValueError(f".byte requires at least one value: {line}")
            # .byte v1, v2, v3...
            # values may be comma-separated or space-separated; handle commas
            vals_str = " ".join(parts[1:])
            vals = [v.strip() for v in vals_str.split(",") if v.strip()]
            pc += len(vals)

        elif op in ("JMP", "JZ"):
            pc += 6

        elif op in OPCODES:
            pc += len(OPCODES[op](parts[1:]))

        else:
            raise ValueError(f"Unknown instruction or directive: {line}")

    return labels


# ---------------------------------------------------------
# PASS 2: Generate machine code (handles .org, .byte, jumps)
# ---------------------------------------------------------
def second_pass(lines, labels):
    output = []

    for orig in lines:
        line = clean_line(orig).strip()
        if not line or line.endswith(":"):
            continue

        parts = line.split()
        op = parts[0].upper()
        args = parts[1:]

        if op == ".ORG":
            if len(args) != 1:
                raise ValueError(f".org requires one argument: {line}")
            addr = int(args[0])
            # pad with zeros up to addr
            while len(output) < addr:
                output.append(0)
            continue

        if op == ".BYTE":
            vals_str = " ".join(args)
            vals = [v.strip() for v in vals_str.split(",") if v.strip()]
            for v in vals:
                output.append(int(v))
            continue

        if op in ("JMP", "JZ"):
            target = args[0]
            if target not in labels:
                raise ValueError(f"Undefined label: {target}")
            addr = labels[target]
            output.extend(expand_jump(op, addr))
            continue

        if op not in OPCODES:
            raise ValueError(f"Unknown instruction: {op}")

        output.extend(OPCODES[op](args))

    return output


# ---------------------------------------------------------
# Top-level assembly pipeline
# ---------------------------------------------------------
def assemble_program(lines):
    # 0: parse vars and consts, produce initializers
    variables, consts, initializers, remaining = parse_vars_and_consts(lines)

    # 0.5: parse macros and remove definitions
    macros, no_macros = parse_macros(remaining)

    # 1: expand macros
    expanded = expand_macros(no_macros, macros)

    # 2: prepend variable initializers
    full_program = initializers + expanded

    # 3: substitute variables and constants
    substituted = substitute_symbols(full_program, variables, consts)

    # 4: first pass (labels)
    labels = first_pass(substituted)

    # 5: second pass (machine code)
    return second_pass(substituted, labels)


def main():
    print("Enter assembly code. End with \"EXIT!!!\"")
    lines = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if line.strip() == "EXIT!!!":
            break
        lines.append(line)

    machine = assemble_program(lines)
    print("\nMachine code (CSV):")
    print(",".join(str(b) for b in machine))


if __name__ == "__main__":
    main()